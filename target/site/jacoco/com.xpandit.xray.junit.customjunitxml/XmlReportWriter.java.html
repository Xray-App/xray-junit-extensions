<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XmlReportWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">xray-junit-extensions</a> &gt; <a href="index.source.html" class="el_package">com.xpandit.xray.junit.customjunitxml</a> &gt; <span class="el_source">XmlReportWriter.java</span></div><h1>XmlReportWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2015-2021 the original author or authors.
 *
 * All rights reserved. This program and the accompanying materials are
 * made available under the terms of the Eclipse Public License v2.0 which
 * accompanies this distribution and is available at
 *
 * https://www.eclipse.org/legal/epl-v20.html
 */

package com.xpandit.xray.junit.customjunitxml;

import com.xpandit.xray.junit.customjunitxml.XmlReportWriter.AggregatedTestResult.Type;
import com.xpandit.xray.junit.customjunitxml.annotations.Requirement;
import com.xpandit.xray.junit.customjunitxml.annotations.XrayTest;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import static java.text.MessageFormat.format;
import static java.time.format.DateTimeFormatter.ISO_LOCAL_DATE_TIME;
import static java.util.Collections.emptyList;
import static java.util.Comparator.naturalOrder;
import static java.util.function.Function.identity;
import static java.util.stream.Collectors.counting;
import static java.util.stream.Collectors.groupingBy;
import static java.util.stream.Collectors.mapping;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;
import java.util.stream.Stream;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.TestFactory;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.extension.TestTemplateInvocationContext;
import org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.platform.commons.logging.Logger;
import org.junit.platform.commons.logging.LoggerFactory;
import org.junit.platform.commons.support.AnnotationSupport;
import static org.junit.platform.commons.util.ExceptionUtils.readStackTrace;
import org.junit.platform.commons.util.ReflectionUtils;
import static org.junit.platform.commons.util.StringUtils.isNotBlank;
import static org.junit.platform.engine.TestExecutionResult.Status.FAILED;
import org.junit.platform.engine.TestSource;
import org.junit.platform.engine.support.descriptor.ClassSource;
import org.junit.platform.engine.support.descriptor.MethodSource;
import static org.junit.platform.launcher.LauncherConstants.STDERR_REPORT_ENTRY_KEY;
import static org.junit.platform.launcher.LauncherConstants.STDOUT_REPORT_ENTRY_KEY;
import static com.xpandit.xray.junit.customjunitxml.XmlReportWriter.AggregatedTestResult.Type.ERROR;
import static com.xpandit.xray.junit.customjunitxml.XmlReportWriter.AggregatedTestResult.Type.FAILURE;
import static com.xpandit.xray.junit.customjunitxml.XmlReportWriter.AggregatedTestResult.Type.SKIPPED;
import static com.xpandit.xray.junit.customjunitxml.XmlReportWriter.AggregatedTestResult.Type.SUCCESS;

import java.io.Writer;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.text.NumberFormat;
import java.time.Instant;
import java.time.format.DateTimeFormatter;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.util.ArrayList;
import java.util.Collection;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Properties;
import java.util.TreeSet;
import java.util.regex.Pattern;
import java.util.Set;
import java.util.stream.Collectors;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Base64;
import java.util.Base64.Encoder;

import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamWriter;

import org.junit.platform.engine.TestExecutionResult;
import org.junit.platform.engine.reporting.ReportEntry;
import org.junit.platform.launcher.TestIdentifier;
import org.junit.platform.launcher.TestPlan;
import org.junit.platform.reporting.legacy.LegacyReportingUtils;
import org.junit.platform.engine.TestTag;
import org.junit.jupiter.api.extension.TestTemplateInvocationContext;

/**
 * {@code XmlReportWriter} writes an XML report whose format is compatible with
 * the de facto standard for JUnit 4 based test reports that was made popular by
 * the Ant build system.
 *
 * @since 1.4
 */
class XmlReportWriter {

	// Using zero-width assertions in the split pattern simplifies the splitting
	// process: All split parts
	// (including the first and last one) can be used directly, without having to
	// re-add separator characters.
<span class="fc" id="L109">	private static final Pattern CDATA_SPLIT_PATTERN = Pattern.compile(&quot;(?&lt;=]])(?=&gt;)&quot;);</span>

	private final XmlReportData reportData;
<span class="fc" id="L112">	private static final Logger logger = LoggerFactory.getLogger(EnhancedLegacyXmlReportGeneratingListener.class);</span>

<span class="fc" id="L114">	XmlReportWriter(XmlReportData reportData) {</span>
<span class="fc" id="L115">		this.reportData = reportData;</span>
<span class="fc" id="L116">	}</span>

	void writeXmlReport(TestIdentifier rootDescriptor, Writer out) throws XMLStreamException {
<span class="fc" id="L119">		TestPlan testPlan = this.reportData.getTestPlan();</span>
<span class="fc" id="L120">		Map&lt;TestIdentifier, AggregatedTestResult&gt; tests = testPlan.getDescendants(rootDescriptor) //</span>
<span class="fc" id="L121">				.stream() //</span>
<span class="fc" id="L122">				.filter(testIdentifier -&gt; shouldInclude(testPlan, testIdentifier)) //</span>
<span class="fc" id="L123">				.collect(toMap(identity(), this::toAggregatedResult)); //</span>
<span class="fc" id="L124">		writeXmlReport(rootDescriptor, tests, out);</span>
<span class="fc" id="L125">	}</span>

	private AggregatedTestResult toAggregatedResult(TestIdentifier testIdentifier) {
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">		if (this.reportData.wasSkipped(testIdentifier)) {</span>
<span class="nc" id="L129">			return AggregatedTestResult.skipped();</span>
		}
<span class="fc" id="L131">		return AggregatedTestResult.nonSkipped(this.reportData.getResults(testIdentifier));</span>
	}

	private boolean shouldInclude(TestPlan testPlan, TestIdentifier testIdentifier) {
<span class="pc bpc" id="L135" title="1 of 4 branches missed.">		return testIdentifier.isTest() || testPlan.getChildren(testIdentifier).isEmpty();</span>
	}

	private void writeXmlReport(TestIdentifier testIdentifier, Map&lt;TestIdentifier, AggregatedTestResult&gt; tests,
			Writer out) throws XMLStreamException {

<span class="fc" id="L141">		XMLOutputFactory factory = XMLOutputFactory.newInstance();</span>
<span class="fc" id="L142">		XMLStreamWriter xmlWriter = factory.createXMLStreamWriter(out);</span>
<span class="fc" id="L143">		xmlWriter.writeStartDocument(&quot;UTF-8&quot;, &quot;1.0&quot;);</span>
<span class="fc" id="L144">		newLine(xmlWriter);</span>
<span class="fc" id="L145">		writeTestsuite(testIdentifier, tests, xmlWriter);</span>
<span class="fc" id="L146">		xmlWriter.writeEndDocument();</span>
<span class="fc" id="L147">		xmlWriter.flush();</span>
<span class="fc" id="L148">		xmlWriter.close();</span>
<span class="fc" id="L149">	}</span>

	private void writeTestsuite(TestIdentifier testIdentifier, Map&lt;TestIdentifier, AggregatedTestResult&gt; tests,
			XMLStreamWriter writer) throws XMLStreamException {

		// NumberFormat is not thread-safe. Thus, we instantiate it here and pass it to
		// writeTestcase instead of using a constant
<span class="fc" id="L156">		NumberFormat numberFormat = NumberFormat.getInstance(Locale.US);</span>

<span class="fc" id="L158">		writer.writeStartElement(&quot;testsuite&quot;);</span>

<span class="fc" id="L160">		writeSuiteAttributes(testIdentifier, tests.values(), numberFormat, writer);</span>

<span class="fc" id="L162">		newLine(writer);</span>
<span class="fc" id="L163">		writeSystemProperties(writer);</span>

<span class="fc bfc" id="L165" title="All 2 branches covered.">		for (Entry&lt;TestIdentifier, AggregatedTestResult&gt; entry : tests.entrySet()) {</span>
<span class="fc" id="L166">			writeTestcase(entry.getKey(), entry.getValue(), numberFormat, writer);</span>
<span class="fc" id="L167">		}</span>

<span class="fc" id="L169">		writeOutputElement(&quot;system-out&quot;, formatNonStandardAttributesAsString(testIdentifier), writer);</span>

<span class="fc" id="L171">		writer.writeEndElement();</span>
<span class="fc" id="L172">		newLine(writer);</span>
<span class="fc" id="L173">	}</span>

	private void writeSuiteAttributes(TestIdentifier testIdentifier, Collection&lt;AggregatedTestResult&gt; testResults,
			NumberFormat numberFormat, XMLStreamWriter writer) throws XMLStreamException {

<span class="fc" id="L178">		writeAttributeSafely(writer, &quot;name&quot;, testIdentifier.getDisplayName());</span>
<span class="fc" id="L179">		writeTestCounts(testResults, writer);</span>
<span class="fc" id="L180">		writeAttributeSafely(writer, &quot;time&quot;, getTime(testIdentifier, numberFormat));</span>
<span class="fc" id="L181">		writeAttributeSafely(writer, &quot;hostname&quot;, getHostname().orElse(&quot;&lt;unknown host&gt;&quot;));</span>
<span class="fc" id="L182">		writeAttributeSafely(writer, &quot;timestamp&quot;, ISO_LOCAL_DATE_TIME.format(getCurrentDateTime()));</span>
<span class="fc" id="L183">	}</span>

	private void writeTestCounts(Collection&lt;AggregatedTestResult&gt; testResults, XMLStreamWriter writer)
			throws XMLStreamException {
<span class="fc" id="L187">		Map&lt;Type, Long&gt; counts = testResults.stream().map(it -&gt; it.type).collect(groupingBy(identity(), counting()));</span>
<span class="fc" id="L188">		long total = counts.values().stream().mapToLong(Long::longValue).sum();</span>
<span class="fc" id="L189">		writeAttributeSafely(writer, &quot;tests&quot;, String.valueOf(total));</span>
<span class="fc" id="L190">		writeAttributeSafely(writer, &quot;skipped&quot;, counts.getOrDefault(SKIPPED, 0L).toString());</span>
<span class="fc" id="L191">		writeAttributeSafely(writer, &quot;failures&quot;, counts.getOrDefault(FAILURE, 0L).toString());</span>
<span class="fc" id="L192">		writeAttributeSafely(writer, &quot;errors&quot;, counts.getOrDefault(ERROR, 0L).toString());</span>
<span class="fc" id="L193">	}</span>

	private void writeSystemProperties(XMLStreamWriter writer) throws XMLStreamException {
<span class="fc" id="L196">		writer.writeStartElement(&quot;properties&quot;);</span>
<span class="fc" id="L197">		newLine(writer);</span>
<span class="fc" id="L198">		Properties systemProperties = System.getProperties();</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">		for (String propertyName : new TreeSet&lt;&gt;(systemProperties.stringPropertyNames())) {</span>
<span class="fc" id="L200">			writer.writeEmptyElement(&quot;property&quot;);</span>
<span class="fc" id="L201">			writeAttributeSafely(writer, &quot;name&quot;, propertyName);</span>
<span class="fc" id="L202">			writeAttributeSafely(writer, &quot;value&quot;, systemProperties.getProperty(propertyName));</span>
<span class="fc" id="L203">			newLine(writer);</span>
<span class="fc" id="L204">		}</span>
<span class="fc" id="L205">		writer.writeEndElement();</span>
<span class="fc" id="L206">		newLine(writer);</span>
<span class="fc" id="L207">	}</span>

	private Optional&lt;Class&lt;?&gt;&gt; getTestClass(final TestSource source) {
<span class="nc bnc" id="L210" title="All 2 branches missed.">		if (source instanceof MethodSource) {</span>
<span class="nc" id="L211">			return getTestClass(((MethodSource) source).getClassName());</span>
		}
<span class="nc bnc" id="L213" title="All 2 branches missed.">		if (source instanceof ClassSource) {</span>
<span class="nc" id="L214">			return Optional.of(((ClassSource) source).getJavaClass());</span>
		}
<span class="nc" id="L216">		return Optional.empty();</span>
	}

	private Optional&lt;Class&lt;?&gt;&gt; getTestClass(final String className) {
		try {
<span class="nc" id="L221">			return Optional.of(Class.forName(className));</span>
<span class="nc" id="L222">		} catch (ClassNotFoundException e) {</span>
<span class="nc" id="L223">			logger.error(e, () -&gt; &quot;Could not get test class from test source &quot; + className);</span>
		}
<span class="nc" id="L225">		return Optional.empty();</span>
	}

	private Optional&lt;Method&gt; getTestMethod(final TestSource source) {
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">		if (source instanceof MethodSource) {</span>
<span class="fc" id="L230">			return getTestMethod((MethodSource) source);</span>
		}
<span class="nc" id="L232">		return Optional.empty();</span>
	}

	private Optional&lt;Method&gt; getTestMethod(final MethodSource source) {
		try {
<span class="fc" id="L237">			final Class&lt;?&gt; aClass = Class.forName(source.getClassName());</span>
<span class="fc" id="L238">			return Stream.of(aClass.getDeclaredMethods()).filter(method -&gt; MethodSource.from(method).equals(source))</span>
<span class="fc" id="L239">					.findAny();</span>
<span class="nc" id="L240">		} catch (ClassNotFoundException e) {</span>
<span class="nc" id="L241">			logger.error(e, () -&gt; &quot;Could not get test method from method source &quot; + source);</span>
		}
<span class="nc" id="L243">		return Optional.empty();</span>
	}

	private HashMap&lt;String, String&gt; getTestRunCustomFields(List&lt;ReportEntry&gt; entries) {
<span class="fc" id="L247">		HashMap&lt;String, String&gt; hash = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L249" title="All 2 branches covered.">		if (!entries.isEmpty()) {</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">			for (int i = 0; i &lt; entries.size(); i++) {</span>
<span class="fc" id="L251">				ReportEntry reportEntry = entries.get(i);</span>
<span class="fc" id="L252">				Map&lt;String, String&gt; testrunCustomFields = reportEntry.getKeyValuePairs().entrySet().stream().filter(</span>
<span class="fc" id="L253">						mapItem -&gt; ((String) mapItem.getKey()).startsWith(XrayTestReporter.TESTRUN_CUSTOMFIELD_PREFIX))</span>
<span class="fc" id="L254">						.collect(Collectors.toMap(map -&gt; ((String) map.getKey()).substring(5), map -&gt; map.getValue()));</span>
<span class="fc" id="L255">				hash.putAll(testrunCustomFields);</span>
			}
		}
<span class="fc" id="L258">		return hash;</span>
	}

	private void writeTestcase(TestIdentifier testIdentifier, AggregatedTestResult testResult,
			NumberFormat numberFormat, XMLStreamWriter writer) throws XMLStreamException {

<span class="fc" id="L264">		writer.writeStartElement(&quot;testcase&quot;);</span>
<span class="fc" id="L265">		writeAttributeSafely(writer, &quot;name&quot;, getName(testIdentifier));</span>
<span class="fc" id="L266">		writeAttributeSafely(writer, &quot;classname&quot;, getClassName(testIdentifier));</span>
<span class="fc" id="L267">		writeAttributeSafely(writer, &quot;time&quot;, getTime(testIdentifier, numberFormat));</span>
<span class="fc" id="L268">		DateTimeFormatter dateFormatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME.withZone(ZoneId.from(ZoneOffset.UTC));</span>
<span class="fc" id="L269">		writeAttributeSafely(writer, &quot;started-at&quot;, getStartedAt(testIdentifier, dateFormatter));</span>
<span class="fc" id="L270">		writeAttributeSafely(writer, &quot;finished-at&quot;, getFinishedAt(testIdentifier, dateFormatter));</span>
<span class="fc" id="L271">		newLine(writer);</span>

<span class="fc" id="L273">		writeSkippedOrErrorOrFailureElement(testIdentifier, testResult, writer);</span>

<span class="fc" id="L275">		List&lt;String&gt; systemOutElements = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L276">		List&lt;String&gt; systemErrElements = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L277">		systemOutElements.add(formatNonStandardAttributesAsString(testIdentifier));</span>
<span class="fc" id="L278">		collectReportEntries(testIdentifier, systemOutElements, systemErrElements);</span>
<span class="fc" id="L279">		writeOutputElements(&quot;system-out&quot;, systemOutElements, writer);</span>
<span class="fc" id="L280">		writeOutputElements(&quot;system-err&quot;, systemErrElements, writer);</span>

<span class="fc" id="L282">		StringBuilder testrunComment = new StringBuilder();</span>
<span class="fc" id="L283">		List&lt;String&gt; testrunComments = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L284">		collectReportEntriesFor(testIdentifier, &quot;xray:comment&quot;, testrunComments);</span>
<span class="fc" id="L285">		testrunComments.forEach((comment) -&gt; testrunComment.append(format(&quot;{0}\n&quot;, comment.trim())));</span>

<span class="fc" id="L287">		writer.writeStartElement(&quot;properties&quot;);</span>
<span class="fc" id="L288">		newLine(writer);</span>

<span class="fc bfc" id="L290" title="All 2 branches covered.">		if (testrunComment.length() &gt; 0) {</span>
<span class="fc" id="L291">			addPropertyWithInnerContent(writer, &quot;testrun_comment&quot;, testrunComment.toString().trim());</span>
<span class="fc" id="L292">			newLine(writer);</span>
		}

<span class="fc" id="L295">		final Optional&lt;TestSource&gt; testSource = testIdentifier.getSource();</span>
<span class="fc" id="L296">		final Optional&lt;Method&gt; testMethod = testSource.flatMap(this::getTestMethod);</span>
		// final Optional&lt;Class&lt;?&gt;&gt; testClass = testSource.flatMap(this::getTestClass);

<span class="fc" id="L299">		Optional&lt;Requirement&gt; requirement = AnnotationSupport.findAnnotation(testMethod, Requirement.class);</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">		if (requirement.isPresent()) {</span>
<span class="fc" id="L301">			String[] requirements = requirement.get().value();</span>
<span class="fc" id="L302">			addProperty(writer, &quot;requirements&quot;, String.join(&quot;,&quot;, requirements));</span>
		}

<span class="fc" id="L305">		Optional&lt;XrayTest&gt; xrayTest = AnnotationSupport.findAnnotation(testMethod, XrayTest.class);</span>
<span class="fc" id="L306">		String test_key = null;</span>
<span class="fc" id="L307">		String test_id = null;</span>
<span class="fc" id="L308">		String test_summary = null;</span>
<span class="fc" id="L309">		String test_description = null;</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">		if (xrayTest.isPresent()) {</span>
<span class="fc" id="L311">			test_key = xrayTest.get().key();</span>
<span class="pc bpc" id="L312" title="1 of 4 branches missed.">			if ((test_key != null) &amp;&amp; (!test_key.isEmpty())) {</span>
<span class="fc" id="L313">				addProperty(writer, &quot;test_key&quot;, test_key);</span>
			}

<span class="fc" id="L316">			test_id = xrayTest.get().id();</span>
<span class="pc bpc" id="L317" title="1 of 4 branches missed.">			if ((test_id != null) &amp;&amp; (!test_id.isEmpty())) {</span>
<span class="fc" id="L318">				addProperty(writer, &quot;test_id&quot;, test_id);</span>
			}

<span class="fc" id="L321">			test_summary = xrayTest.get().summary();</span>
<span class="fc" id="L322">			test_description = xrayTest.get().description();</span>
<span class="pc bpc" id="L323" title="1 of 4 branches missed.">			if ((test_description != null) &amp;&amp; (!test_description.isEmpty())) {</span>
<span class="fc" id="L324">				addPropertyWithInnerContent(writer, &quot;test_description&quot;, test_description);</span>
			}
		}

<span class="fc" id="L328">		Optional&lt;ParameterizedTest&gt; paramterizedTest = AnnotationSupport.findAnnotation(testMethod, ParameterizedTest.class);</span>
<span class="fc" id="L329">		Optional&lt;TestFactory&gt; dynamicTest = AnnotationSupport.findAnnotation(testMethod, TestFactory.class);</span>
<span class="fc" id="L330">		Optional&lt;DisplayName&gt; displayName = AnnotationSupport.findAnnotation(testMethod, DisplayName.class);</span>
<span class="fc bfc" id="L331" title="All 6 branches covered.">		if ( ((test_summary == null) || (test_summary.isEmpty())) &amp;&amp; (displayName.isPresent()) ) {</span>
			//test_summary = testIdentifier.getDisplayName();
<span class="fc" id="L333">			test_summary = displayName.get().value();</span>
		}
<span class="fc bfc" id="L335" title="All 6 branches covered.">		if ( ((test_summary == null) || (test_summary.isEmpty())) &amp;&amp; (dynamicTest.isPresent()) ) {</span>
<span class="fc" id="L336">			test_summary = testIdentifier.getDisplayName();</span>
		}
<span class="fc bfc" id="L338" title="All 4 branches covered.">		if ((test_summary != null) &amp;&amp; (!test_summary.isEmpty())) {</span>
<span class="fc" id="L339">			addProperty(writer, &quot;test_summary&quot;, test_summary);</span>
		}

<span class="fc" id="L342">		List&lt;String&gt; tags = testIdentifier.getTags().stream().map(TestTag::getName).map(String::trim)</span>
<span class="fc" id="L343">				.collect(Collectors.toList());</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">		if (!tags.isEmpty()) {</span>
<span class="fc" id="L345">			addProperty(writer, &quot;tags&quot;, String.join(&quot;,&quot;, tags));</span>
		}

		// TODO: get arguments
		// Object[] args = argumentsFrom(testIdentifier);
		// System.out.println(&quot;xargs: &quot; + args);
		// System.out.println(&quot;xargs.len: &quot; + args.length);

<span class="fc" id="L353">		List&lt;ReportEntry&gt; entries = this.reportData.getReportEntries(testIdentifier);</span>
<span class="fc" id="L354">		HashMap&lt;String, String&gt; testrunCustomFields = getTestRunCustomFields(entries);</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">		for (Map.Entry customField : testrunCustomFields.entrySet()) {</span>
<span class="fc" id="L356">			addProperty(writer, (String) customField.getKey(), (String) customField.getValue());</span>
<span class="fc" id="L357">		}</span>

<span class="fc bfc" id="L359" title="All 2 branches covered.">		if (!entries.isEmpty()) {</span>
<span class="fc" id="L360">			writer.writeStartElement(&quot;property&quot;);</span>
<span class="fc" id="L361">			writeAttributeSafely(writer, &quot;name&quot;, &quot;testrun_evidence&quot;);</span>
<span class="fc" id="L362">			newLine(writer);</span>

<span class="fc bfc" id="L364" title="All 2 branches covered.">			for (int i = 0; i &lt; entries.size(); i++) {</span>
<span class="fc" id="L365">				ReportEntry reportEntry = entries.get(i);</span>

<span class="fc" id="L367">				List&lt;String&gt; files = reportEntry.getKeyValuePairs().entrySet().stream()</span>
<span class="fc" id="L368">						.filter(mapItem -&gt; ((String) mapItem.getKey()).equals(XrayTestReporter.TESTRUN_EVIDENCE))</span>
<span class="fc" id="L369">						.map(item -&gt; item.getValue()).collect(Collectors.toList());</span>

<span class="fc" id="L371">				Base64.Encoder enc = Base64.getEncoder();</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">				for (String file : files) {</span>
					try {
<span class="fc" id="L374">						byte[] fileContent = Files.readAllBytes(Paths.get(file));</span>
<span class="fc" id="L375">						byte[] encoded = enc.encode(fileContent);</span>
<span class="fc" id="L376">						String encodedStr = new String(encoded, &quot;UTF-8&quot;);</span>
<span class="fc" id="L377">						addEvidence(writer, new File(file).getName(), encodedStr);</span>
<span class="nc" id="L378">					} catch (Exception e) {</span>
<span class="nc" id="L379">						logger.error(e, () -&gt; &quot;error encoding evidence &quot; + file);</span>
<span class="fc" id="L380">					}</span>
<span class="fc" id="L381">				}</span>
			}

<span class="fc" id="L384">			writer.writeEndElement(); // property testrun_evidence</span>
<span class="fc" id="L385">			newLine(writer);</span>
		}

<span class="fc" id="L388">		writer.writeEndElement(); // properties</span>
<span class="fc" id="L389">		newLine(writer);</span>

<span class="fc" id="L391">		writer.writeEndElement(); // testcase</span>
<span class="fc" id="L392">		newLine(writer);</span>
<span class="fc" id="L393">	}</span>

	private void addProperty(XMLStreamWriter writer, String name, String value) throws XMLStreamException {
<span class="fc" id="L396">		writer.writeEmptyElement(&quot;property&quot;);</span>
<span class="fc" id="L397">		writeAttributeSafely(writer, &quot;name&quot;, name);</span>
<span class="fc" id="L398">		writeAttributeSafely(writer, &quot;value&quot;, value);</span>
<span class="fc" id="L399">		newLine(writer);</span>
<span class="fc" id="L400">	}</span>

	private void addPropertyWithInnerContent(XMLStreamWriter writer, String name, String value)
			throws XMLStreamException {
<span class="fc" id="L404">		writer.writeStartElement(&quot;property&quot;);</span>
<span class="fc" id="L405">		writeAttributeSafely(writer, &quot;name&quot;, name);</span>
<span class="fc" id="L406">		writeCDataSafely(writer, value);</span>
<span class="fc" id="L407">		writer.writeEndElement();</span>
<span class="fc" id="L408">		newLine(writer);</span>
<span class="fc" id="L409">	}</span>

	private void addEvidence(XMLStreamWriter writer, String name, String content) throws XMLStreamException {
<span class="fc" id="L412">		writer.writeStartElement(&quot;item&quot;);</span>
<span class="fc" id="L413">		writeAttributeSafely(writer, &quot;name&quot;, name);</span>
<span class="fc" id="L414">		writer.writeCharacters(content);</span>
<span class="fc" id="L415">		writer.writeEndElement();</span>
<span class="fc" id="L416">		newLine(writer);</span>
<span class="fc" id="L417">	}</span>

	private String getName(TestIdentifier testIdentifier) {
<span class="fc" id="L420">		String legacyName = testIdentifier.getLegacyReportingName();</span>
<span class="fc" id="L421">		int pos = legacyName.indexOf('(');</span>
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">		if (pos &gt; 0) {</span>
<span class="fc" id="L423">			return legacyName.substring(0, pos);</span>
		} else {
<span class="nc" id="L425">			return legacyName.substring(0, -1);</span>
			// return legacyName;
		}
	}

	private String getClassName(TestIdentifier testIdentifier) {
<span class="fc" id="L431">		return LegacyReportingUtils.getClassName(this.reportData.getTestPlan(), testIdentifier);</span>
	}

	private void writeSkippedOrErrorOrFailureElement(TestIdentifier testIdentifier, AggregatedTestResult testResult,
			XMLStreamWriter writer) throws XMLStreamException {

<span class="pc bpc" id="L437" title="1 of 2 branches missed.">		if (testResult.type == SKIPPED) {</span>
<span class="nc" id="L438">			writeSkippedElement(this.reportData.getSkipReason(testIdentifier), writer);</span>
		} else {
<span class="fc" id="L440">			Map&lt;Type, List&lt;Optional&lt;Throwable&gt;&gt;&gt; throwablesByType = testResult.getThrowablesByType();</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">			for (Type type : EnumSet.of(FAILURE, ERROR)) {</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">				for (Optional&lt;Throwable&gt; throwable : throwablesByType.getOrDefault(type, emptyList())) {</span>
<span class="fc" id="L443">					writeErrorOrFailureElement(type, throwable.orElse(null), writer);</span>
<span class="fc" id="L444">				}</span>
<span class="fc" id="L445">			}</span>
		}
<span class="fc" id="L447">	}</span>

	private void writeSkippedElement(String reason, XMLStreamWriter writer) throws XMLStreamException {
<span class="nc bnc" id="L450" title="All 2 branches missed.">		if (isNotBlank(reason)) {</span>
<span class="nc" id="L451">			writer.writeStartElement(&quot;skipped&quot;);</span>
<span class="nc" id="L452">			writeCDataSafely(writer, reason);</span>
<span class="nc" id="L453">			writer.writeEndElement();</span>
		} else {
<span class="nc" id="L455">			writer.writeEmptyElement(&quot;skipped&quot;);</span>
		}
<span class="nc" id="L457">		newLine(writer);</span>
<span class="nc" id="L458">	}</span>

	private void writeErrorOrFailureElement(Type type, Throwable throwable, XMLStreamWriter writer)
			throws XMLStreamException {

<span class="pc bpc" id="L463" title="1 of 2 branches missed.">		String elementName = type == FAILURE ? &quot;failure&quot; : &quot;error&quot;;</span>
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">		if (throwable != null) {</span>
<span class="fc" id="L465">			writer.writeStartElement(elementName);</span>
<span class="fc" id="L466">			writeFailureAttributesAndContent(throwable, writer);</span>
<span class="fc" id="L467">			writer.writeEndElement();</span>
		} else {
<span class="nc" id="L469">			writer.writeEmptyElement(elementName);</span>
		}
<span class="fc" id="L471">		newLine(writer);</span>
<span class="fc" id="L472">	}</span>

	private void writeFailureAttributesAndContent(Throwable throwable, XMLStreamWriter writer)
			throws XMLStreamException {

<span class="pc bpc" id="L477" title="1 of 2 branches missed.">		if (throwable.getMessage() != null) {</span>
<span class="fc" id="L478">			writeAttributeSafely(writer, &quot;message&quot;, throwable.getMessage());</span>
		}
<span class="fc" id="L480">		writeAttributeSafely(writer, &quot;type&quot;, throwable.getClass().getName());</span>
<span class="fc" id="L481">		writeCDataSafely(writer, readStackTrace(throwable));</span>
<span class="fc" id="L482">	}</span>

	private void collectReportEntries(TestIdentifier testIdentifier, List&lt;String&gt; systemOutElements,
			List&lt;String&gt; systemErrElements) {
<span class="fc" id="L486">		List&lt;ReportEntry&gt; entries = this.reportData.getReportEntries(testIdentifier);</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">		if (!entries.isEmpty()) {</span>
<span class="fc" id="L488">			List&lt;String&gt; systemOutElementsForCapturedOutput = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L489">			StringBuilder formattedReportEntries = new StringBuilder();</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">			for (int i = 0; i &lt; entries.size(); i++) {</span>
<span class="fc" id="L491">				ReportEntry reportEntry = entries.get(i);</span>
<span class="fc" id="L492">				Map&lt;String, String&gt; keyValuePairs = new LinkedHashMap&lt;&gt;(reportEntry.getKeyValuePairs());</span>
<span class="fc" id="L493">				removeIfPresentAndAddAsSeparateElement(keyValuePairs, STDOUT_REPORT_ENTRY_KEY,</span>
						systemOutElementsForCapturedOutput);
<span class="fc" id="L495">				removeIfPresentAndAddAsSeparateElement(keyValuePairs, STDERR_REPORT_ENTRY_KEY, systemErrElements);</span>
<span class="fc" id="L496">				removeXrayKeys(keyValuePairs);</span>
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">				if (!keyValuePairs.isEmpty()) {</span>
<span class="nc" id="L498">					buildReportEntryDescription(reportEntry.getTimestamp(), keyValuePairs, i + 1,</span>
							formattedReportEntries);
				}
			}
<span class="fc" id="L502">			systemOutElements.add(formattedReportEntries.toString().trim());</span>
<span class="fc" id="L503">			systemOutElements.addAll(systemOutElementsForCapturedOutput);</span>
		}
<span class="fc" id="L505">	}</span>

	private void collectReportEntriesFor(TestIdentifier testIdentifier, String entryName, List&lt;String&gt; elements) {
<span class="fc" id="L508">		List&lt;ReportEntry&gt; entries = this.reportData.getReportEntries(testIdentifier);</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">		if (!entries.isEmpty()) {</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">			for (int i = 0; i &lt; entries.size(); i++) {</span>
<span class="fc" id="L511">				ReportEntry reportEntry = entries.get(i);</span>
<span class="fc" id="L512">				List&lt;String&gt; tempComments = reportEntry.getKeyValuePairs().entrySet().stream()</span>
<span class="fc" id="L513">						.filter(mapItem -&gt; ((String) mapItem.getKey()).equals(entryName)).map(item -&gt; item.getValue())</span>
<span class="fc" id="L514">						.collect(Collectors.toList());</span>
<span class="fc" id="L515">				elements.addAll(tempComments);</span>
			}
		}
<span class="fc" id="L518">	}</span>

	private void removeXrayKeys(Map&lt;String, String&gt; keyValuePairs) {
<span class="fc" id="L521">		keyValuePairs.entrySet().removeIf(entry -&gt; ((String) entry.getKey()).startsWith(XrayTestReporter.XRAY_PREFIX));</span>
<span class="fc" id="L522">	}</span>

	private void removeIfPresentAndAddAsSeparateElement(Map&lt;String, String&gt; keyValuePairs, String key,
			List&lt;String&gt; elements) {
<span class="fc" id="L526">		String value = keyValuePairs.remove(key);</span>
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">		if (value != null) {</span>
<span class="nc" id="L528">			elements.add(value);</span>
		}
<span class="fc" id="L530">	}</span>

	private void buildReportEntryDescription(LocalDateTime timestamp, Map&lt;String, String&gt; keyValuePairs,
			int entryNumber, StringBuilder result) {
<span class="nc" id="L534">		result.append(</span>
<span class="nc" id="L535">				format(&quot;Report Entry #{0} (timestamp: {1})\n&quot;, entryNumber, ISO_LOCAL_DATE_TIME.format(timestamp)));</span>
<span class="nc" id="L536">		keyValuePairs.forEach((key, value) -&gt; result.append(format(&quot;\t- {0}: {1}\n&quot;, key, value)));</span>
<span class="nc" id="L537">	}</span>

	private String getTime(TestIdentifier testIdentifier, NumberFormat numberFormat) {
<span class="fc" id="L540">		return numberFormat.format(this.reportData.getDurationInSeconds(testIdentifier));</span>
	}

	private String getStartedAt(TestIdentifier testIdentifier, DateTimeFormatter dateFormatter) {
<span class="fc" id="L544">		return dateFormatter.format(this.reportData.getStartInstant(testIdentifier));</span>
	}

	private String getFinishedAt(TestIdentifier testIdentifier, DateTimeFormatter dateFormatter) {
<span class="fc" id="L548">		return dateFormatter.format(this.reportData.getEndInstant(testIdentifier));</span>
	}

	private Optional&lt;String&gt; getHostname() {
		try {
<span class="fc" id="L553">			return Optional.ofNullable(InetAddress.getLocalHost().getHostName());</span>
<span class="nc" id="L554">		} catch (UnknownHostException e) {</span>
<span class="nc" id="L555">			return Optional.empty();</span>
		}
	}

	private LocalDateTime getCurrentDateTime() {
<span class="fc" id="L560">		return LocalDateTime.now(this.reportData.getClock()).withNano(0);</span>
	}

	private String formatNonStandardAttributesAsString(TestIdentifier testIdentifier) {
<span class="fc" id="L564">		return &quot;unique-id: &quot; + testIdentifier.getUniqueId() //</span>
<span class="fc" id="L565">				+ &quot;\ndisplay-name: &quot; + testIdentifier.getDisplayName();</span>
	}

	private void writeOutputElements(String elementName, List&lt;String&gt; elements, XMLStreamWriter writer)
			throws XMLStreamException {
<span class="fc bfc" id="L570" title="All 2 branches covered.">		for (String content : elements) {</span>
<span class="fc" id="L571">			writeOutputElement(elementName, content, writer);</span>
<span class="fc" id="L572">		}</span>
<span class="fc" id="L573">	}</span>

	private void writeOutputElement(String elementName, String content, XMLStreamWriter writer)
			throws XMLStreamException {
<span class="fc" id="L577">		writer.writeStartElement(elementName);</span>
<span class="fc" id="L578">		writeCDataSafely(writer, &quot;\n&quot; + content + &quot;\n&quot;);</span>
<span class="fc" id="L579">		writer.writeEndElement();</span>
<span class="fc" id="L580">		newLine(writer);</span>
<span class="fc" id="L581">	}</span>

	private void writeAttributeSafely(XMLStreamWriter writer, String name, String value) throws XMLStreamException {
<span class="fc" id="L584">		writer.writeAttribute(name, escapeIllegalChars(value));</span>
<span class="fc" id="L585">	}</span>

	private void writeCDataSafely(XMLStreamWriter writer, String data) throws XMLStreamException {
<span class="fc bfc" id="L588" title="All 2 branches covered.">		for (String safeDataPart : CDATA_SPLIT_PATTERN.split(escapeIllegalChars(data))) {</span>
<span class="fc" id="L589">			writer.writeCData(safeDataPart);</span>
		}
<span class="fc" id="L591">	}</span>

	static String escapeIllegalChars(String text) {
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">		if (text.codePoints().allMatch(XmlReportWriter::isAllowedXmlCharacter)) {</span>
<span class="fc" id="L595">			return text;</span>
		}
<span class="nc" id="L597">		StringBuilder result = new StringBuilder(text.length() * 2);</span>
<span class="nc" id="L598">		text.codePoints().forEach(codePoint -&gt; {</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">			if (isAllowedXmlCharacter(codePoint)) {</span>
<span class="nc" id="L600">				result.appendCodePoint(codePoint);</span>
			} else { // use a Character Reference (cf. https://www.w3.org/TR/xml/#NT-CharRef)
<span class="nc" id="L602">				result.append(&quot;&amp;#&quot;).append(codePoint).append(';');</span>
			}
<span class="nc" id="L604">		});</span>
<span class="nc" id="L605">		return result.toString();</span>
	}

	private static boolean isAllowedXmlCharacter(int codePoint) {
		// source: https://www.w3.org/TR/xml/#charsets
<span class="pc bpc" id="L610" title="11 of 18 branches missed.">		return codePoint == 0x9 //</span>
				|| codePoint == 0xA //
				|| codePoint == 0xD //
				|| (codePoint &gt;= 0x20 &amp;&amp; codePoint &lt;= 0xD7FF) //
				|| (codePoint &gt;= 0xE000 &amp;&amp; codePoint &lt;= 0xFFFD) //
				|| (codePoint &gt;= 0x10000 &amp;&amp; codePoint &lt;= 0x10FFFF);
	}

	private void newLine(XMLStreamWriter xmlWriter) throws XMLStreamException {
<span class="fc" id="L619">		xmlWriter.writeCharacters(&quot;\n&quot;);</span>
<span class="fc" id="L620">	}</span>

	private static boolean isFailure(TestExecutionResult result) {
<span class="fc" id="L623">		Optional&lt;Throwable&gt; throwable = result.getThrowable();</span>
<span class="pc bpc" id="L624" title="2 of 4 branches missed.">		return throwable.isPresent() &amp;&amp; throwable.get() instanceof AssertionError;</span>
	}

	static class AggregatedTestResult {

<span class="fc" id="L629">		private static final AggregatedTestResult SKIPPED_RESULT = new AggregatedTestResult(SKIPPED, emptyList());</span>

		public static AggregatedTestResult skipped() {
<span class="nc" id="L632">			return SKIPPED_RESULT;</span>
		}

		public static AggregatedTestResult nonSkipped(List&lt;TestExecutionResult&gt; executionResults) {
<span class="fc" id="L636">			Type type = executionResults.stream() //</span>
<span class="fc" id="L637">					.map(Type::from) //</span>
<span class="fc" id="L638">					.max(naturalOrder()) //</span>
<span class="fc" id="L639">					.orElse(SUCCESS);</span>
<span class="fc" id="L640">			return new AggregatedTestResult(type, executionResults);</span>
		}

		private final Type type;
		private final List&lt;TestExecutionResult&gt; executionResults;

<span class="fc" id="L646">		private AggregatedTestResult(Type type, List&lt;TestExecutionResult&gt; executionResults) {</span>
<span class="fc" id="L647">			this.type = type;</span>
<span class="fc" id="L648">			this.executionResults = executionResults;</span>
<span class="fc" id="L649">		}</span>

		public Map&lt;Type, List&lt;Optional&lt;Throwable&gt;&gt;&gt; getThrowablesByType() {
<span class="fc" id="L652">			return executionResults.stream() //</span>
<span class="fc" id="L653">					.collect(groupingBy(Type::from, mapping(TestExecutionResult::getThrowable, toList())));</span>
		}

<span class="fc" id="L656">		enum Type {</span>

<span class="fc" id="L658">			SUCCESS, SKIPPED, FAILURE, ERROR;</span>

			private static Type from(TestExecutionResult executionResult) {
<span class="fc bfc" id="L661" title="All 2 branches covered.">				if (executionResult.getStatus() == FAILED) {</span>
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">					return isFailure(executionResult) ? FAILURE : ERROR;</span>
				}
<span class="fc" id="L664">				return SUCCESS;</span>
			}
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>